//------------------------------------------------------------------------------
// <auto-generated>
//	This code was generated by a tool
//	Changes will be lost if code is regenerated
// </auto-generated>
//------------------------------------------------------------------------------
#ifndef __SPARK_RENDERER_SHADER_GLSL_FOR_GLES2_FEATURE_LEVEL_GLSLES10_DEFAULTSHADER_HPP_INCLUDED__
#define __SPARK_RENDERER_SHADER_GLSL_FOR_GLES2_FEATURE_LEVEL_GLSLES10_DEFAULTSHADER_HPP_INCLUDED__

namespace spark {
	namespace renderer {
		namespace shader {
			namespace glsl_for_gles2_feature_level_glsles10 {
				/// <summary>
				///
				/// <summary>
				class DefaultShader
				{
				public:
					/// <summary>
					///
					/// <summary>
					DefaultShader(void)
					{
					}

					/// <summary>
					///
					/// <summary>
					virtual ~DefaultShader(void)
					{
					}

				public:
					/// <summary>
					///
					/// <summary>
					const char* GetVertexShader() const
					{
						const char* vertexShaderStr =
							"#version 100\n"
							"precision mediump float;\n"
							"\n"
							"// Input\n"
							"attribute vec3 aVertexPosition;\n"
							"attribute vec3 aVertexNormal;\n"
							"attribute vec4 aVertexColor;\n"
							"attribute vec2 aTextureCoord;\n"
							"attribute vec3 aBarycentric;\n"
							"uniform vec3 uLightDirection;\n"
							"uniform mat4 uModelViewProjectionMatrix;\n"
							"\n"
							"// Varying\n"
							"varying vec4 color;\n"
							"varying vec3 vertexNormal;\n"
							"varying vec2 textureCoord;\n"
							"varying vec3 lightDirection;\n"
							"varying vec3 barycentric;\n"
							"\n"
							"//--------------------------------------------------------------------------------------\n"
							"//\n"
							"//--------------------------------------------------------------------------------------\n"
							"void main()\n"
							"{    \n"
							"    color = aVertexColor;\n"
							"    vertexNormal = aVertexNormal;\n"
							"    textureCoord = aTextureCoord;\n"
							"    lightDirection = uLightDirection;\n"
							"    barycentric = aBarycentric;\n"
							"\n"
							"    gl_Position = uModelViewProjectionMatrix * vec4(aVertexPosition, 1.0);\n"
							"}\n"
							"\n"
							"\n"
							;
						return vertexShaderStr;
					}

					/// <summary>
					///
					/// <summary>
					const char* GetFragmentShader() const
					{
						const char* fragmentShaderStr =
							"#version 100\n"
							"precision mediump float;\n"
							"\n"
							"// Varying\n"
							"varying vec4 color;\n"
							"varying vec3 vertexNormal;\n"
							"varying vec2 textureCoord;\n"
							"varying vec3 lightDirection;\n"
							"varying vec3 barycentric;\n"
							"\n"
							"// Input\n"
							"uniform sampler2D uTexture0;\n"
							"uniform int uDrawMode;\n"
							"uniform vec3 uFontColor;\n"
							"\n"
							"//--------------------------------------------------------------------------------------\n"
							"// uDrawMode (uniform) sets the draw mode for this draw call.\n"
							"// DrawMode = 1: Used to draw texture\n"
							"// DrawMode = 2: Used to draw glyphs\n"
							"// DrawMode = 3: Used to draw Normal Vector Debug Visualization for mesh\n"
							"// DrawMode = 4: Used to draw mesh with each triangle filled using its barycenter RGB color\n"
							"// DrawMode = 5: Used to draw mesh as wireframe\n"
							"//--------------------------------------------------------------------------------------\n"
							"void main()\n"
							"{\n"
							"    if(uDrawMode == 1)\n"
							"    {\n"
							"        gl_FragColor = texture2D(uTexture0, textureCoord);\n"
							"    }\n"
							"    else if(uDrawMode == 2)\n"
							"    {\n"
							"        float alpha = texture2D(uTexture0, textureCoord.xy).x;\n"
							"        gl_FragColor = vec4(uFontColor, alpha);\n"
							"    }\n"
							"    else if(uDrawMode == 3)\n"
							"    {\n"
							"        vec3 n = normalize(vertexNormal.xyz);\n"
							"        gl_FragColor = vec4(n * 0.5 + 0.5, 1.0);\n"
							"    }\n"
							"    else if(uDrawMode == 4)\n"
							"    {\n"
							"        gl_FragColor = vec4(barycentric, 1.0);\n"
							"    }\n"
							"    else if(uDrawMode == 5)\n"
							"    {\n"
							"        float edge = min(min(barycentric.x, barycentric.y), barycentric.z);\n"
							"        float thickness = 0.001;        \n"
							"        if (edge < thickness)\n"
							"            gl_FragColor = vec4(0.75, 0.75, 0.75, 1.0);\n"
							"        else\n"
							"            discard;\n"
							"    }\n"
							"    else\n"
							"    {        \n"
							"        gl_FragColor = color;\n"
							"    }\n"
							"}\n"
							"\n"
							"\n"
							"\n"
							;
						return fragmentShaderStr;
					}

				};
			}
		}
	}
}
#endif
